\section{Wybór platformy}
W ramach wstępnych badań do pracy zostały porównane funkcjonalności platform:
\begin{itemize}
    \item \href{https://www.atlassian.com/software/jira}{Jira}
    \item \href{https://www.jetbrains.com/youtrack/}{YouTrack}
\end{itemize}

\subsection*{Badanie możliwości REST API}
W początkowej fazie pracy, projekt miał opierać się o rest api, udostępniane przez każdą z platform. \cite{JiraApiDocumentation} \cite{YouTrackApiDocumentation}
W tej sekcji często wykorzystywane są pojęcia mogące brzmieć podobnie, warto zacząć więc od zdefiniowania prostego słownika:
\begin{itemize}
    \item id projektu -- wewnętrzny identyfikator przydzielany projektom przy utworzeniu
    \item klucz projektu -- akronim nazwy projektu lub nazwa projektu skrócona do kilku liter
    \item id zadania -- wewnętrzny identyfikator przydzielany zadaniom przy utworzeniu
    \item klucz zadania -- identyfikator zadań bardziej czytelny dla człowieka, numer zadania w kolejności chronologicznej, prefiksowany kluczem projektu.
    Przykładowo, projekt o kluczu \texttt{AG} będzie posiadał zadania o kluczach \texttt{AG-1, AG-2}, itd.
\end{itemize}

W celu pobrania danych zadania należy wykonać zapytanie \texttt{GET} odpowiednio na adres:
\begin{itemize}
    \item \texttt{https://[instancja jiry]/rest/api/2/issues/[id/key]} -- Jira
    \item \texttt{https://[instancja youtracka]/api/issues/[id]} -- YouTrack
\end{itemize}


W przypadku Jiry odpowiedź zawiera kompletny zestaw danych -- poza podstawowym informacjami jak id, klucz czy projekt do którego należy zadanie, otrzymujemy również ogromną ilość
danych związanych z historią zadania, możliwościami operacji na zadaniu, a nawet metadanych związanych z szablonami wykorzystanymi do tworzenia projektu lub użytych rozszerzeń.
YouTrack domyślnie zwraca bardzo okrojony zestaw danych -- jedynie typ projektu. "Rest" api YouTracka nie spełnia założeń architektury REST \cite{RoyTFieldingRest}, strukturą i sposobem korzystania przypomina 
bardziej takie rozwiązanie jak \href{https://graphql.org/}{GraphQL}. Wszystkie pola, które chcemy uzyskać w odpowiedzi musimy umieścić w parametrach zapytania.
Przykładowo, aby uzyskać nazwę zadania oraz datę jego utworzenia, należy dodać parametr \texttt{?fields=name,created}. Jest to dobre rozwiązanie pod kątem optymalizacji liczby zapytań oraz zużycia zasobów, jednak
w znaczący sposób komplikuje ono użytkowanie api, bardzo mocno przywiązując użytkownika do dokumentacji w celu odnalezienia informacji o dostępnych danych. W przypadku niekompletności dokumentacji reverse-engineering jest niemożliwy.
Dodatkową wadą YouTracka w porównaniu do Jiry była niemożliwość identyfikacji zadań w zapytaniach po ich kluczach. Konieczne było uzyskanie ich id, co można było osiągnąć de facto tylko przez każdorazowe dodatkowe zapytanie o projekt z listą zadań, w której z kolei
również trzeba było sprecyzować aby zwrócić ich id w parametrach zapytania. Już ta jedna różnica na starcie zasadniczo przechyliła szalę na korzyść Jiry.

Najistotniejsze z punktu widzenia projektu były tutaj dane związane z historią zadań, konkretnie historią przejść pomiędzy statusami.
Informacje potrzebne do realizacji projektu to przede wszystkim daty -- rozpoczęcia i zakończenia zadania (jeżeli zostało już zakończone), oraz wszystkich przejść pomiędzy statusami, z informacją
z jakiego do jakiego statusu przeszło w danym momencie. Jedyne dane z tego zakresu jakie można było znaleźć w odpowiedzi to daty utworzenia zadania i jego ostatniej aktualizacji.
W przypadku obu serwisów dokumentacja api nie opisuje danych stricte związanych z taką historią, jedynie szczątkowe dane takie jak data utworzenia, zamknięcia czy ostatniej aktualizacji (tj. dowolnej operacji związanej z konkretnym zadaniem).
Przyjmując uproszczenie poprzez postawienie znaku równości pomiędzy datą utworzenia zadania i datą jego rozpoczęcia, nadal nie można by przeanalizować efektywności przepływu, a analiza reszty metryk byłaby dość przybliżona.
Moment utworzenia zadania nie jest jednoznaczny z rozpoczęciem pracy nad nim, ponieważ po utworzeniu nadal może ono czekać przez pewien czas w backlogu zanim osiągnie punkt zobowiązania.
Utworzenie zadania bez statusu nie jest możliwe w graficznym interfejsie żadnej z platform, jednak da się to zrobić w inny sposób, co zostanie opisane w dalszej części pracy.

W celu utworzenie zadania należy wykonać zapytanie \texttt{POST} odpowiednio na adres:
\begin{itemize}
    \item \texttt{https://[instancja jiry]/rest/api/2/issues} -- Jira
    \item \texttt{https://[instancja youtracka]/api/issues} -- YouTrack
\end{itemize}
W przypadku pomyślnego utworzenia zadania, api obu platform zwraca w odpowiedzi datę utworzenia zadania.
Jira korzysta ze standardu ISO 8601, natomiast YouTrack z formatu Unix Time \cite{UnixProgrammersManual}.
Dokumentacje obu platform nie wspominają możliwości ustawienia tego pola. W przypadku Jiry próba kończy się odpowiedzią \texttt{400 Bad Request}, a YouTrack po prostu po cichu ignoruje tę daną
w ciele zapytania.\\
Na tym etapie praca nad projektem została mocno spowolniona, ponieważ żadne z api nie udostępnia ani wszystkich potrzebnych danych do kompletnej analizy metryk, ani nie pozwala nawet ich ręcznie wprowadzić -- daty każdej operacji
są automatycznie nadawane przez serwer i api nie pozwala w żaden sposób na obejście tego mechanizmu.

\subsection*{Poszukiwanie alternatywy dla REST API}
W związku z brakiem potrzebnych do realizacji projektu funkcjonalności w rest api obydwu platform, konieczne było poszukiwanie alternatywnego rozwiązania.
YouTrack nie oferuje tutaj żadnych specjalnych funkcjonalności, natomiast Jira posiada swój własny język do tworzenia zapytań -- JQL (Jira Query Language). \cite{YouTrackSearch} \cite{JiraJQL}
Na tym etapie projekt skupił się w całości na platformie Jira. Zapoznanie się z podstawami JQL było inwestycją czasu, która zwróciła się z nawiązką, szczególnie kiedy znalazłem również bibliotekę \href{https://pypi.org/project/jiraone/}{jiraone} do języka Python,
która pozwala na eksport danych uzyskanych za pomocą JQL do plików \texttt{.json}. Skrypt do takiego eksportu danych zdecydowanie przyspieszył ich zdobywanie, oraz uprościł przechowywanie ich do późniejszej analizy.
Dane zdobyte za pomocą JQL okazały się bardziej kompletne -- tutaj już można było odnaleźć informacje o historii poszczególnych zadań. Analiza danych pozyskana w ten sposób była również prostsza, z uwagi na możliwość nałożenia filtrów i zawężenia ich
jedynie do tych istotnych na dany moment.\\
Po dalszych badaniach udało znaleźć się alternatywny sposób wypełniania projektów zadaniami -- narzędzie do migracji danych z zewnętrznego źródła do Jiry. \cite{JiraImportExport}
Jira pozwala importować dane z różnych źródeł, ale szczególną uwagę przykuły pliki \texttt{.csv} oraz \texttt{.json} ze względu na prostotę.
Dokumentacja importu z obu formatów okazała się dość wybrakowana pod kątem danych istotnych dla projektu. Jednak jako że eksport za pomocą JQL zwracał format JSON, reverse-engineering za pomocą wcześniej napisanych skryptów w Pythonie nie był
żadnym problemem.

% TODO opis struktury historii
